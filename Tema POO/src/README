Nume : Marinas Adrian-Claudiu
Grupa : 325 CC


	Task 1
	Pentru task-ul 1 am creat o interfata Repository(pe care am si implementat-o) pentru obiectele de tip Directory si Fisier care imi extind aceasta interfata. Pe langa aceasta, am mai folosit o interfata Command pe care o implementez in fiecare comanda a mea. Aceasta este "baza" de la care am pornit tema. Clasele principale sunt Directory, Fisier si User. In prima din ele, am un ArrayList de tip Repository in care retin toti fiii directorului. Una din metodele acestei clase este addChild. Aceasta primeste ca argument un Repository, Director/Fisier, imi parcurge array-ul sa verifice daca exista cumva un Director/Fisier cu acelasi nume, in cazul negativ, imi adauga la arraylist repository-ul. Practic imi construieste, pentru directorul curent, ierarhia de fisiere si directoare. Aceasta clasa mai retine si permisiunile unui director. In cazul in care sunt introduse alaturi de comanda de creare a unui director, atunci ele sunt citite si adaugate, daca nu, sunt preluate cele ale directorului parinte. Nu voi detalia foarte mult implementarea deoarece mi-ar lua mai mult decat tema propriu-zisa, de aceea nu am sa vorbesc despre cum am implementat data curenta, sau ce fac variabilele alese pe parcursul implementarii. Urmatoarea clasa din cele enumerate este Fisier. In aceasta clasa am un constructor care imi initializeaza numele, dimensiunea, permisiunile fisierului dorit pentru a se crea. User este cea de-a treia, unde am de asemenea un constructor care imi initializeaza numele, prenumele, username-ul si parola unui user nou creat. In aceasta clasa mai am de asemenea si o metoda de login, care primeste un username si o parola si verifica daca sunt egale cu cele ale obiectului user creat. Aceasta o folosesc la login cand parcurg array-ul de useri sa verific daca gasesc un user cu datele specificate in comanda. De la aceste 3 clase am inceput realizarea comenzilor. In main citesc (initial de la tastatura, apoi am schimbat system.in, voi detalia la Task 3) o comanda pe care o impart folosind ca delimitator blank-ul. Intr-un switch case verific ce comanda este dorita, mergand pe ramura respectiva si realizand comanda. Newuser este una din ele, cea care imi citeste username-ul, parola, numele si prenumele si imi initializeaza un user cu aceste date, pe care il introduc si in array-ul de useri initiat de asemenea in main. Login imi verifica intai daca user-ul dorit este root, iar daca nu, cauta prin vectorul de useri unul care sa aiba aceleasi date ca cele date de la tastatura(acelasi username si pass). In caz afirmativ, noul user va fi cel gasit. Folosind Singleton Pattern, pot instantia doar o data, adica pot avea doar un user logat in sistem. Logout imi face user-ul curent guest, la fel ca si in momentul cand programul este executat. Userinfo, dupa cum ii spune si numele, imi afiseaza datele despre user-ul logat in sistem, folosind toString-ul din clasa User. Comanda ls este putin mai ampla, aceasta putand lua mai multi parametrii. In cazul in care nu are parametrii, aceasta imi parcurge arraylist-ul din directorul curent si imi adauga intr-un string numele fiilor acestuia si evident ii afiseaza. Daca user-ul care doreste sa faca aceasta comanda (la fel ca si cele ce urmeaza), este guest, atunci nu i se permite. Daca este root, transforma toate permisiunile in true, luand un semafor in cazul in care acestea erau false, iar dupa ce se executa comanda, acestea revin la cele initiale. In cazul unui user oarecare, se verifica permisiunile directorului curent (pentru asta am folosit doua clase, Write si Read pe care le extind comenzile de write si respectiv read, acestea verificandu-mi daca "canBeExecuted", adica daca permisiunile sunt true) si daca se permite, se executa comanda. In cazul parametrului "-a", se afiseaza detalii despre fisierul dat de asemenea dupa parametrul "-a". Pentru parametrul "-r", apelez recursiv pe un director, afisand numele tuturor directoarelor si subdirectoarelor alaturi de fisierele corespunzatoare directorului curent. "-ar" face acelasi lucru, doar ca pe langa nume, afiseaza si celelalte date despre directoare/fisiere. Comanda "echo" imi afiseaza tot ceea ce se afla dupa ea(nu am mai facut clasa separata si pentru asta). Comanda "cat"(nu stiu daca am inteles bine ce trb sa faca), imi afiseaza detaliile despre fisierul dorit. Mkdir imi verifica ceea ce dau ca argument, daca dau si permisiunile sau nu , apoi imi adauga in directorul curent un nou director(addChild). Comanda touch, la fel ca si mkdir se foloseste de metoda addChild pentru a imi adauga in directorul curent fisierul dorit. Apoi imi adauga pe tot path-ul dimensiunea fisierului creat (incrementeaza dimensiunile directoarelor situate pe path-ul spre fisier). Comanda "pwd" imi afiseaza path-ul actual(pe care il salvez intr-un string cu numele "path"). Comanda "rm" imi sterge din arraylist-ul directorului curent, directorul/fisierul dorit, daca aceasta operatie este permisa. Comanda cd, in cazul in care este urmata de "..", imi schimba directorul curent in directorul parinte directorului curent, apoi daca mai sunt comenzi (ex : ../name/..), verifica daca este tot "..", daca da, trec iarasi in directorul parinte directorului curent, daca nu, caut in directorul curent numele directorului in care se vrea a ajunge si trec in el. In cazul in care prima oara primesc un nume, atunci imi intra in directorul cu acel nume. Daca mai am si alte comenzi, atunci le execut la fel ca mai devreme. 
	Bonusuri suplimentare :
 	-Comanda chmod, care imi permite sa schimb permisiunile unui director/fisier in cazul in care sunt logat ca root
	-Pot avea fisiere/directoare cu acelasi nume in ierarhie, dar nu si in acelasi folder
	-In cazul unor comenzi, pot adauga in orice ordine parametrii lor

	Cam asta este in mare ceea ce am facut la task-ul 1. Mai am obiectul Logger, clasa Logger care imi salveaza ceea ce se intampla in sistem (pt exceptii, login, logout), si imi afiseaza intr-un fisier. Pentru acest task am alocat cel mai mult timp, fiind baza temei si fiind foarte multe lucruri de implementat.

	Task 2
	Pentru task-ul 2 am creat 3 clase : CloudService, Station si StoreStation. Legat de MachineId, am preferat sa nu il folosesc pentru ca fiecare director al meu retine si directorul parinte, iar in implementarea mea nu am nevoie sa retin id-ul statiei pe care am scindat ierarhia, fiind o functie recursiva care imi cauta pe toate 3 statiile pentru a reface ierarhia initiala. In prima dintre clase, retin cele 3 statii care au fiecare cate 10 kb (10.000). Aceasta contine 2 metode recursive, upload si sync. Prima din ele primeste un director ca parametru, imi verifica daca am loc sa il introduc pe vreo statie. In caz afirmativ, adaug toti fiii lui pe statia unde are loc. In caz negativ, parcurg fiii acestuia. Daca gaseste un fisier, verifica daca are loc pe vreuna din statii, daca nu, arunca o exceptie de tip MyNotEnoughSpaceException. Daca gaseste un director, apeleaza din nou functia de upload cu acel director. Upload-ul imi adauga in hashset-ul din StoreStation ierarhia directorului dorit pt a fi uploadat. A doua metoda, sync, imi cauta pe fiecare statie director-ul dorit pt a se reface. Parcurg iterativ hashset-ul, daca gasesc un director si numele parintelui acestuia este numele parintelui dorit pt a se reface, il adaug cu metoda addChild, la fel si in cazul unui fisier. Mai precis, imi construiesc ierarhia de sus in jos, gasind intai fiii directorului pt care dau sync, apoi apeland metoda sync recursiv pentru fiii acestuia, cautand nepotii directorului si tot asa. Ceea ce am uitat sa precizez este ca inainte de a face sync, golesc tot directorul. Adica daca dau sync(dir), intai fac remove pe tot ce are dir, apoi sync pt a reface ierarhia. 
	Asta am facut la task-ul 2, e functionabil si nu are nici o exceptie, permitandu-mi in orice moment sa sterg sau sa creez noi fisiere/directoare. 

	Task 3
	Task-ul 3 a fost o placere sa il realizez, e ca un premiu dupa munca depusa. Am creat asadar un JFrame in care am daugat un jlabel(imaginea de sus), un jpanel cu jscrollpane pentru istoric-ul din mijloc si un jtextfield scrollable pentru terminal. JPanel-ului i-am adaugat in boxlayout orientat dupa axa y, ca sa imi adauge pe coloana, iar de fiecare data cand dau o comanda, adaug in acesta un jtextarea care are setat textul pe care comanda il returneaza. Pentru imaginea de sus, m-am folosit putin si de photoshop ca sa creez acea sigla. Mai vreau sa specific ca istoricul apare in momentul in care user-ul da click pe el, pentru a fi vizibil doar in momentul in care acesta doreste. Parametrii -POO imi fac exact ceea ce facea comanda, numai ca imi pune output-ul in JTable, JList sau respectiv JDialog. Pe acestea le adaug in jpanel-ul history, iar in cazul lui JDialog, creez o noua fereastra in care imi adauga textul dorit. 
	Bonusuri suplimentare :
	-Grafica este in mare un bonus suplimentar. Am folosit photoshop-ul, am adaugat imagine, l-am facut sa arate cat de cat acceptabil si real. 
	-am implementat de asemenea Look and Feel, fiind nevoie insa pentru testare de adaugarea a doua jar-uri in libraries, pe care le-am atasat si in folder-ul cu surse. 

	Tema nu a fost una complicata, subiectul ales este foarte potrivit pentru a ne acomoda cu acest limbaj de programare. Timpul alocat a fost unul destul de lung pentru ca m-a pasionat aceasta tema si am incercat sa iasa cat mai bine. Imi cer scuze pentru main-ul putin cam lung, dar nu mai am timp ca sa il impart in metode. 
	


	
	
